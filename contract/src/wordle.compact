pragma language_version >= 0.16 && <= 0.18;

import CompactStandardLibrary;
export { Maybe }

export struct Word {
  first_letter : Uint<8>;
  second_letter : Uint<8>;
  third_letter : Uint<8>;
  fourth_letter : Uint<8>;
  fifth_letter : Uint<8>;
}

export struct GuessResult {
  first_letter_result : Uint<2>;
  second_letter_result : Uint<2>;
  third_letter_result : Uint<2>;
  fourth_letter_result : Uint<2>;
  fifth_letter_result : Uint<2>;
}

enum GAME_STATE { 
  waiting_p1,
  waiting_p2, 
  p1_guess_turn,
  p2_guess_turn,
  p1_wins,
  p2_wins,
  draw
}

// Game state management
export ledger game_state: GAME_STATE;
export ledger current_guess: Word;                    // Current guess being made
export ledger last_guess_result: Maybe<GuessResult>; // Result of last guess

// Player 1 state
export ledger p1: Maybe<Bytes<32>>;                     // Player 1 identity hash
export ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // Player 1 public key
export ledger p1_word_hash: Bytes<32>;                  // Player 1 word commitment
export ledger p1_guess_count: Counter;       // Number of guesses made

// Player 2 state  
export ledger p2: Maybe<Bytes<32>>;                     // Player 2 identity hash
export ledger p2_public_key: Maybe<ZswapCoinPublicKey>; // Player 2 public key
export ledger p2_word_hash: Bytes<32>;                  // Player 2 word commitment
export ledger p2_guess_count: Counter;                 // Number of guesses made

// Private witness functions
witness local_secret_key(): Bytes<32>;                  // Player's secret key for identity
witness player_word(): Vector<5, Uint<8>>;              // Player's secret word
witness player_salt(): Bytes<32>;                       // Player's salt for commitment

// Helper function to generate player identity from secret key
export pure circuit public_key(sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([pad(32, "wordle:pk:"), sk]);
}

constructor() {
  game_state = GAME_STATE.waiting_p1;
  p1_guess_count.resetToDefault();
  p2_guess_count.resetToDefault();
  // Initialize with non-English characters that won't match any real word
  // Using characters like '@', '#', '$', '%', '&' (ASCII 64, 35, 36, 37, 38)
  current_guess = disclose(Word {
    first_letter: 64,   // '@'
    second_letter: 35,  // '#'
    third_letter: 36,   // '$'
    fourth_letter: 37,  // '%'
    fifth_letter: 38    // '&'
  });
}
// Player 1 joins the game
export circuit join_p1(): [] {
  assert (game_state == GAME_STATE.waiting_p1, "Game is not waiting for player 1");
  assert (!p1.is_some, "Player 1 already joined");
  
  const sk = local_secret_key();
  // Generate unique secret key for this game instance
  const secret_key = persistentHash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);
  const me = public_key(sk);
  
  p1 = disclose(some<Bytes<32>>(me));
  p1_public_key = some<ZswapCoinPublicKey>(ownPublicKey());
  
  // Commit to word using hash(word + salt + secret_key)
  const word = player_word();
  const salt = player_salt();
  p1_word_hash = disclose(persistentHash<Vector<3, Bytes<32>>>([
    persistentHash<Vector<5, Uint<8>>>(word),
    salt,
    secret_key
  ]));

  game_state = GAME_STATE.waiting_p2;
}

// Player 2 joins the game  
export circuit join_p2(): [] {
  assert (game_state == GAME_STATE.waiting_p2, "Game is not waiting for player 2");
  assert (!p2.is_some, "Player 2 already joined");
  
  const sk = local_secret_key();
  const secret_key = persistentHash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);
  const me = public_key(sk);
  
  // Ensure different players
  assert (p1.value != me, "Cannot play against yourself");
  
  p2 = disclose(some<Bytes<32>>(me));
  p2_public_key = some<ZswapCoinPublicKey>(ownPublicKey());
  
  const word = player_word();
  const salt = player_salt();
  p2_word_hash = disclose(persistentHash<Vector<3, Bytes<32>>>([
    persistentHash<Vector<5, Uint<8>>>(word),
    salt,
    secret_key
  ]));
  
  game_state = GAME_STATE.p1_guess_turn;
}

// Player 1's turn to guess Player 2's word
export circuit turn_player1(guess: Word): [] {
  assert (game_state == GAME_STATE.p1_guess_turn, "Not player 1's guess turn");
  assert (p1_guess_count < 6, "Player 1 has used all guesses");
  
  const sk = local_secret_key();
  const me = public_key(sk);
  assert (p1.value == me, "You are not player 1");
  
  // Only verify P2's guess if P2 has actually made a guess
  verify_p2_guess();
  
  
  current_guess = disclose(guess);
  p1_guess_count.increment(1);
  
  // Player 2 will verify this guess
  game_state = GAME_STATE.p2_guess_turn;
  //last_guess_result = disclose(none<GuessResult>());
}

// Player 2 verifies Player 1's guess
export circuit verify_p1_guess(): [] {
  assert (game_state == GAME_STATE.p2_guess_turn, "Not player 2's verify turn");
  
  const sk = local_secret_key();
  const secret_key = persistentHash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);
  const me = public_key(sk);
  assert (p2.value == me, "You are not player 2");
  
  // Verify Player 1's guess against Player 2's word
  const my_word = player_word();
  const my_salt = player_salt();
  
  // Verify word commitment hasn't changed
  const word_hash = persistentHash<Vector<3, Bytes<32>>>([
    persistentHash<Vector<5, Uint<8>>>(my_word),
    my_salt, 
    secret_key
  ]);
  assert (word_hash == p2_word_hash, "Word commitment mismatch");
  
  // Convert word to struct for evaluation
  const word_struct = Word {
    first_letter: disclose(my_word[0] as Uint<8>),
    second_letter: disclose(my_word[1] as Uint<8>), 
    third_letter: disclose(my_word[2] as Uint<8>),
    fourth_letter: disclose(my_word[3] as Uint<8>),
    fifth_letter: disclose(my_word[4] as Uint<8>)
  };
  
  // Evaluate Player 1's guess
  const result = disclose(evaluate_guess(word_struct, current_guess));
  last_guess_result = disclose(some<GuessResult>(result));
  
  // Check if Player 1 won
  if (disclose(result.first_letter_result) == 2 && disclose(result.second_letter_result) == 2 && 
      disclose(result.third_letter_result) == 2 && disclose(result.fourth_letter_result) == 2 && 
      disclose(result.fifth_letter_result) == 2) {
    game_state = GAME_STATE.p1_wins;
    return;
  }
  
  // Check if Player 1 used all guesses
  if (p1_guess_count >= 6) {
    if (p2_guess_count >= 6) {
      game_state = GAME_STATE.draw;
    } else {
      game_state = GAME_STATE.p2_wins;
    }
    return;
  }
  
}

// Player 2's turn to guess Player 1's word
export circuit turn_player2(guess: Word): [] {
  assert (game_state == GAME_STATE.p2_guess_turn, "Not player 2's guess turn");
  assert (p2_guess_count < 6, "Player 2 has used all guesses");
  
  const sk = local_secret_key();
  const me = public_key(sk);
  assert (p2.value == me, "You are not player 2");
  
  // Always verify P1's guess since P2 only plays after P1 has made at least one guess
  verify_p1_guess();
  
  current_guess = disclose(guess);
  p2_guess_count.increment(1);
  
  //last_guess_result = disclose(none<GuessResult>());
  game_state = GAME_STATE.p1_guess_turn;
}

// Player 1 verifies Player 2's guess
export circuit verify_p2_guess(): [] {
  assert (game_state == GAME_STATE.p1_guess_turn, "Not player 1's verify turn");
  
  const sk = local_secret_key();
  const secret_key = persistentHash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);
  const me = public_key(sk);
  assert (p1.value == me, "You are not player 1");
  
  // Verify Player 2's guess against Player 1's word
  const my_word = player_word();
  const my_salt = player_salt();
  
  // Verify word commitment
  const word_hash = persistentHash<Vector<3, Bytes<32>>>([
    persistentHash<Vector<5, Uint<8>>>(my_word),
    my_salt,
    secret_key  
  ]);
  assert (word_hash == p1_word_hash, "Word commitment mismatch");
  
  const word_struct = Word {
    first_letter: disclose(my_word[0] as Uint<8>),
    second_letter: disclose(my_word[1] as Uint<8>),
    third_letter: disclose(my_word[2] as Uint<8>), 
    fourth_letter: disclose(my_word[3] as Uint<8>),
    fifth_letter: disclose(my_word[4] as Uint<8>)
  };
  
  const result = disclose(evaluate_guess(word_struct, current_guess));
  last_guess_result = disclose(some<GuessResult>(result));
  
  // Check if Player 2 won
  if (disclose(result.first_letter_result) == 2 && disclose(result.second_letter_result) == 2 &&
      disclose(result.third_letter_result) == 2 && disclose(result.fourth_letter_result) == 2 && 
      disclose(result.fifth_letter_result) == 2) {
    game_state = GAME_STATE.p2_wins;
    return;
  }
  
  // Check game end conditions
  if (p2_guess_count >= 6) {
    if (p1_guess_count >= 6) {
      game_state = GAME_STATE.draw;
    } else {
      game_state = GAME_STATE.p1_wins;
    }
    return;
  }
  
  // Continue to Player 1's guess turn
}

// Pure function to evaluate a guess against a word
pure circuit evaluate_guess(word: Word, guess: Word): GuessResult {
  return GuessResult {
    first_letter_result: evaluate_letter(word, guess, 0),
    second_letter_result: evaluate_letter(word, guess, 1), 
    third_letter_result: evaluate_letter(word, guess, 2),
    fourth_letter_result: evaluate_letter(word, guess, 3),
    fifth_letter_result: evaluate_letter(word, guess, 4)
  };
}

pure circuit evaluate_letter(word: Word, guess: Word, position: Uint<3>): Uint<2> {
  const guess_letter = get_letter_at_position(guess, position);
  const word_letter = get_letter_at_position(word, position);
  
  if (guess_letter == word_letter) {
    return 2; // Correct position (green)
  } else if (guess_letter == word.first_letter || guess_letter == word.second_letter || 
             guess_letter == word.third_letter || guess_letter == word.fourth_letter || 
             guess_letter == word.fifth_letter) {
    return 1; // Wrong position but in word (yellow)
  } else {
    return 0; // Not in word (gray)
  }
}

pure circuit get_letter_at_position(word: Word, position: Uint<3>): Uint<8> {
  if (position == 0) {
    return word.first_letter;
  } else if (position == 1) {
    return word.second_letter;
  } else if (position == 2) {
    return word.third_letter;
  } else if (position == 3) {
    return word.fourth_letter;
  } else {
    return word.fifth_letter;
  }
}