pragma language_version >= 0.16 && <= 0.18;

import CompactStandardLibrary;
export { Maybe }

export struct Word {
  first_letter : Uint<8>;
  second_letter : Uint<8>;
  third_letter : Uint<8>;
  fourth_letter : Uint<8>;
  fifth_letter : Uint<8>;
}

export struct GuessResult {
  first_letter_result : Uint<2>;
  second_letter_result : Uint<2>;
  third_letter_result : Uint<2>;
  fourth_letter_result : Uint<2>;
  fifth_letter_result : Uint<2>;
}

enum GAME_STATE { 
  waiting_p1,
  waiting_p2, 
  p1_guess_turn,
  p2_guess_turn,
  p1_wins,
  p2_wins,
  draw
}

export struct PlayerResult {
  guess_words : Vector<6, Word>;
  guess_results : Vector<6, GuessResult>;
}
// Game state management
export ledger game_state: GAME_STATE;
export ledger p1_current_guess: Word;                  // Player 1's current guess
export ledger p2_current_guess: Word;                  // Player 2's current guess

// Player 1 state
export ledger p1: Maybe<Bytes<32>>;                     // Player 1 identity hash
export ledger p1_public_key: Maybe<ZswapCoinPublicKey>; // Player 1 public key
export ledger p1_word_hash: Bytes<32>;                  // Player 1 word commitment
export ledger p1_guess_count: Counter;       // Number of guesses made
export ledger p1_last_guess_result: Maybe<GuessResult>; // Result of last guess
export ledger p1_results: PlayerResult;          // Player 1's guesses and results

// Player 2 state  
export ledger p2: Maybe<Bytes<32>>;                     // Player 2 identity hash
export ledger p2_public_key: Maybe<ZswapCoinPublicKey>; // Player 2 public key
export ledger p2_word_hash: Bytes<32>;                  // Player 2 word commitment
export ledger p2_guess_count: Counter;                 // Number of guesses made
export ledger p2_last_guess_result: Maybe<GuessResult>; // Result of last guess
export ledger p2_results: PlayerResult;          // Player 2's guesses and results
// Private witness functions
witness local_secret_key(): Bytes<32>;                  // Player's secret key for identity
witness player_word(): Vector<5, Uint<8>>;              // Player's secret word
witness player_salt(): Bytes<32>;                       // Player's salt for commitment

// Helper function to generate player identity from secret key
export pure circuit public_key(sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([pad(32, "wordle:pk:"), sk]);
}

constructor() {
  game_state = GAME_STATE.waiting_p1;
  p1_guess_count.resetToDefault();
  p2_guess_count.resetToDefault();
  
  // Initialize player results with empty data
  const emptyWord = default<Word>;
  const emptyResult = default<GuessResult>;

  const words: Vector<6, Word> = [emptyWord, emptyWord, emptyWord, emptyWord, emptyWord, emptyWord];
  const results: Vector<6, GuessResult> = [emptyResult, emptyResult, emptyResult, emptyResult, emptyResult, emptyResult];

  p1_results = PlayerResult { guess_words: words, guess_results: results };
  p2_results = PlayerResult { guess_words: words, guess_results: results };
  
  // Initialize with non-English characters that won't match any real word
  // Using characters  '.' (ASCII 46)
  const emptyGuess = Word {
    first_letter: 46,   // '.'
    second_letter: 46,  // '.'
    third_letter: 46,   // '.'
    fourth_letter: 46,  // '.'
    fifth_letter: 46   // '.'
  };
  p1_current_guess = disclose(emptyGuess);
  p2_current_guess = disclose(emptyGuess);
}
// Player 1 joins the game
export circuit join_p1(): [] {
  assert (game_state == GAME_STATE.waiting_p1, "Game is not waiting for player 1");
  assert (!p1.is_some, "Player 1 already joined");
  
  const sk = local_secret_key();
  // Generate unique secret key for this game instance
  const secret_key = persistentHash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);
  const me = public_key(sk);
  
  p1 = disclose(some<Bytes<32>>(me));
  p1_public_key = some<ZswapCoinPublicKey>(ownPublicKey());
  
  // Commit to word using hash(word + salt + secret_key)
  const word = player_word();
  const salt = player_salt();
  p1_word_hash = disclose(persistentHash<Vector<3, Bytes<32>>>([
    persistentHash<Vector<5, Uint<8>>>(word),
    salt,
    secret_key
  ]));

  game_state = GAME_STATE.waiting_p2;
}

// Player 2 joins the game  
export circuit join_p2(): [] {
  assert (game_state == GAME_STATE.waiting_p2, "Game is not waiting for player 2");
  assert (!p2.is_some, "Player 2 already joined");
  
  const sk = local_secret_key();
  const secret_key = persistentHash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);
  const me = public_key(sk);
  
  // Ensure different players
  assert (p1.value != me, "Cannot play against yourself");
  
  p2 = disclose(some<Bytes<32>>(me));
  p2_public_key = some<ZswapCoinPublicKey>(ownPublicKey());
  
  const word = player_word();
  const salt = player_salt();
  p2_word_hash = disclose(persistentHash<Vector<3, Bytes<32>>>([
    persistentHash<Vector<5, Uint<8>>>(word),
    salt,
    secret_key
  ]));
  
  game_state = GAME_STATE.p1_guess_turn;
}

// Player 1's turn to guess Player 2's word
export circuit turn_player1(guess: Word): [] {
  assert (game_state == GAME_STATE.p1_guess_turn, "Not player 1's guess turn");
  assert (p1_guess_count < 6, "Player 1 has used all guesses");
  
  const sk = local_secret_key();
  const me = public_key(sk);
  assert (p1.value == me, "You are not player 1");
  
  // Store Player 1's guess BEFORE verification (use current count as index)
  const guess_index = p1_guess_count.read();
  
  // Manually update the specific index in the vector
  const current_words = p1_results.guess_words;
  const new_words = [
    (guess_index == (0 as Uint<64>)) ? disclose(guess) : current_words[0],
    (guess_index == (1 as Uint<64>)) ? disclose(guess) : current_words[1], 
    (guess_index == (2 as Uint<64>)) ? disclose(guess) : current_words[2],
    (guess_index == (3 as Uint<64>)) ? disclose(guess) : current_words[3],
    (guess_index == (4 as Uint<64>)) ? disclose(guess) : current_words[4],
    (guess_index == (5 as Uint<64>)) ? disclose(guess) : current_words[5]
  ];
  p1_results = disclose(PlayerResult { 
    guess_words: new_words, 
    guess_results: p1_results.guess_results 
  });
  
  // Clear previous result BEFORE making new guess
  p1_last_guess_result = disclose(none<GuessResult>());
  
  p1_current_guess = disclose(guess);
  p1_guess_count.increment(1);
  
  // Only verify P2's guess if P2 has actually made a guess
  verify_p2_guess();
  
  // Check if game ended due to verification (P2 won or draw)
  if (game_state != GAME_STATE.p1_guess_turn) {
    return; // Game ended, don't continue
  }
  
  // Player 2 will verify this guess
  game_state = GAME_STATE.p2_guess_turn;
}

// Player 2 verifies Player 1's guess

export circuit verify_p1_guess(): [] {
  assert (game_state == GAME_STATE.p2_guess_turn, "Not player 2's verify turn");
  
  const sk = local_secret_key();
  const secret_key = persistentHash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);
  const me = public_key(sk);
  assert (p2.value == me, "You are not player 2");
  
  // Verify Player 1's guess against Player 2's word
  const my_word = player_word();
  const my_salt = player_salt();
  
  // Verify word commitment hasn't changed
  const word_hash = persistentHash<Vector<3, Bytes<32>>>([
    persistentHash<Vector<5, Uint<8>>>(my_word),
    my_salt, 
    secret_key
  ]);
  assert (word_hash == p2_word_hash, "Word commitment mismatch");
  
  // Convert word to struct for evaluation
  const word_struct = Word {
    first_letter: disclose(my_word[0] as Uint<8>),
    second_letter: disclose(my_word[1] as Uint<8>), 
    third_letter: disclose(my_word[2] as Uint<8>),
    fourth_letter: disclose(my_word[3] as Uint<8>),
    fifth_letter: disclose(my_word[4] as Uint<8>)
  };
  
  // Evaluate Player 1's guess against Player 2's word
  const result = disclose(evaluate_guess(word_struct, p1_current_guess));
  p1_last_guess_result = disclose(some<GuessResult>(result));

  // Store only the result (using count-1 since count was already incremented)
  const guess_index = (p1_guess_count.read() - (1 as Uint<64>)) as Uint<64>;
  
  // Manually update the specific index in the vector
  const current_results = p1_results.guess_results;
  const new_results = [
    (guess_index == (0 as Uint<64>)) ? result : current_results[0],
    (guess_index == (1 as Uint<64>)) ? result : current_results[1], 
    (guess_index == (2 as Uint<64>)) ? result : current_results[2],
    (guess_index == (3 as Uint<64>)) ? result : current_results[3],
    (guess_index == (4 as Uint<64>)) ? result : current_results[4],
    (guess_index == (5 as Uint<64>)) ? result : current_results[5]
  ];
  p1_results = disclose(PlayerResult { 
    guess_words: p1_results.guess_words, 
    guess_results: new_results 
  });

  
  // Check if Player 1 won
  if (disclose(result.first_letter_result) == 2 && disclose(result.second_letter_result) == 2 && 
      disclose(result.third_letter_result) == 2 && disclose(result.fourth_letter_result) == 2 && 
      disclose(result.fifth_letter_result) == 2) {
    game_state = GAME_STATE.p1_wins;
    return;
  }
  
  // Check if Player 1 used all guesses
  if (p1_guess_count >= 6) {
    if (p2_guess_count >= 6) {
      game_state = GAME_STATE.draw;
    } else {
      game_state = GAME_STATE.p2_wins;
    }
    return;
  }
  
}

// Player 2's turn to guess Player 1's word
export circuit turn_player2(guess: Word): [] {
  assert (game_state == GAME_STATE.p2_guess_turn, "Not player 2's guess turn");
  assert (p2_guess_count < 6, "Player 2 has used all guesses");
  
  const sk = local_secret_key();
  const me = public_key(sk);
  assert (p2.value == me, "You are not player 2");
  
  // Store Player 2's guess BEFORE verification (use current count as index)
  const guess_index = p2_guess_count.read();
  
  // Manually update the specific index in the vector
  const current_words = p2_results.guess_words;
  const new_words = [
    (guess_index == (0 as Uint<64>)) ? disclose(guess) : current_words[0],
    (guess_index == (1 as Uint<64>)) ? disclose(guess) : current_words[1], 
    (guess_index == (2 as Uint<64>)) ? disclose(guess) : current_words[2],
    (guess_index == (3 as Uint<64>)) ? disclose(guess) : current_words[3],
    (guess_index == (4 as Uint<64>)) ? disclose(guess) : current_words[4],
    (guess_index == (5 as Uint<64>)) ? disclose(guess) : current_words[5]
  ];
  p2_results = disclose(PlayerResult { 
    guess_words: new_words, 
    guess_results: p2_results.guess_results 
  });
  
  // Clear previous result BEFORE making new guess
  p2_last_guess_result = disclose(none<GuessResult>());
  
  p2_current_guess = disclose(guess);
  p2_guess_count.increment(1);
  
  // Always verify P1's guess since P2 only plays after P1 has made at least one guess
  verify_p1_guess();
  
  // Check if game ended due to verification (P1 won or draw)
  if (game_state != GAME_STATE.p2_guess_turn) {
    return; // Game ended, don't continue
  }
  
  game_state = GAME_STATE.p1_guess_turn;
}

// Player 1 verifies Player 2's guess
export circuit verify_p2_guess(): [] {
  // If Player 2 hasn't made any guesses yet, nothing to verify
  if (p2_guess_count.read() == (0 as Uint<64>)) {
    return;
  }
  
  const sk = local_secret_key();
  const secret_key = persistentHash<Vector<2, Bytes<32>>>([sk, kernel.self().bytes]);
  const me = public_key(sk);
  assert (p1.value == me, "You are not player 1");
  
  // Verify Player 2's guess against Player 1's word
  const my_word = player_word();
  const my_salt = player_salt();
  
  // Verify word commitment
  const word_hash = persistentHash<Vector<3, Bytes<32>>>([
    persistentHash<Vector<5, Uint<8>>>(my_word),
    my_salt,
    secret_key  
  ]);
  assert (word_hash == p1_word_hash, "Word commitment mismatch");
  
  const word_struct = Word {
    first_letter: disclose(my_word[0] as Uint<8>),
    second_letter: disclose(my_word[1] as Uint<8>),
    third_letter: disclose(my_word[2] as Uint<8>), 
    fourth_letter: disclose(my_word[3] as Uint<8>),
    fifth_letter: disclose(my_word[4] as Uint<8>)
  };
  
  const result = disclose(evaluate_guess(word_struct, p2_current_guess));
  p2_last_guess_result = disclose(some<GuessResult>(result));

  // Store only the result (using count-1 since count was already incremented)
  const guess_index = (p2_guess_count.read() - (1 as Uint<64>)) as Uint<64>;
  
  // Manually update the specific index in the vector
  const current_results = p2_results.guess_results;
  const new_results = [
    (guess_index == (0 as Uint<64>)) ? result : current_results[0],
    (guess_index == (1 as Uint<64>)) ? result : current_results[1], 
    (guess_index == (2 as Uint<64>)) ? result : current_results[2],
    (guess_index == (3 as Uint<64>)) ? result : current_results[3],
    (guess_index == (4 as Uint<64>)) ? result : current_results[4],
    (guess_index == (5 as Uint<64>)) ? result : current_results[5]
  ];
  p2_results = disclose(PlayerResult { 
    guess_words: p2_results.guess_words, 
    guess_results: new_results 
  });
  
  // Check if Player 2 won
  if (disclose(result.first_letter_result) == 2 && disclose(result.second_letter_result) == 2 &&
      disclose(result.third_letter_result) == 2 && disclose(result.fourth_letter_result) == 2 && 
      disclose(result.fifth_letter_result) == 2) {
    game_state = GAME_STATE.p2_wins;
    return;
  }
  
  // Check game end conditions
  if (p2_guess_count >= 6) {
    if (p1_guess_count >= 6) {
      game_state = GAME_STATE.draw;
    } else {
      game_state = GAME_STATE.p1_wins;
    }
    return;
  }
  
  // Continue to Player 1's guess turn
}

// Pure function to evaluate a guess against a word
pure circuit evaluate_guess(word: Word, guess: Word): GuessResult {
  return GuessResult {
    first_letter_result: evaluate_letter(word, guess, 0),
    second_letter_result: evaluate_letter(word, guess, 1), 
    third_letter_result: evaluate_letter(word, guess, 2),
    fourth_letter_result: evaluate_letter(word, guess, 3),
    fifth_letter_result: evaluate_letter(word, guess, 4)
  };
}

pure circuit evaluate_letter(word: Word, guess: Word, position: Uint<3>): Uint<2> {
  const guess_letter = get_letter_at_position(guess, position);
  const word_letter = get_letter_at_position(word, position);
  
  if (guess_letter == word_letter) {
    return 2; // Correct position (green)
  } else if (guess_letter == word.first_letter || guess_letter == word.second_letter || 
             guess_letter == word.third_letter || guess_letter == word.fourth_letter || 
             guess_letter == word.fifth_letter) {
    return 1; // Wrong position but in word (yellow)
  } else {
    return 0; // Not in word (gray)
  }
}

pure circuit get_letter_at_position(word: Word, position: Uint<3>): Uint<8> {
  if (position == 0) {
    return word.first_letter;
  } else if (position == 1) {
    return word.second_letter;
  } else if (position == 2) {
    return word.third_letter;
  } else if (position == 3) {
    return word.fourth_letter;
  } else {
    return word.fifth_letter;
  }
}